#include "split.h"
#include "rand.h"
#include "rand.h"

/*
void proc_timer(void);
int upper_send(u8 dmac, u8 smac, void *msg, int msglen);
int upper_recv(u8 *buf, int *len);
int lower_fetch(u8 *buf, int *len);
int lower_put(void *raw_frm, int rawlen);
void split_init();
void split_cleanup();
*/

#define NUM_OF_TESTS	100000
#define GEN_ERR		1
//#define VERBOSE	1

int main()
{
	//u8 s[] = "";
	//u8 s[] = "abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz";
	u8 crc;
	u8 s[LINK_DATA_MAX];
	u8 r[sizeof s];
	u8 low[LINK_MTU];
	int len;
	int ret;
	int n;
	int fail = 0;
	int i;
	bool again = true;
	u8 data1[]= {0x7e, 0x03, 0x91, 0x35, 0x0d, 0xa8, 0x0e, 0x4b,
	             0x5d, 0xd9, 0x10, 0xd1, 0xaa, 0x77, 0x54, 0x3d,
		     0x90, 0x9c, 0xe9, 0xe9, 0x64, 0xfc, 0xe5, 0xd1,
		     0x66, 0x4a, 0xc8, 0x00, 0x1d, 0x9b, 0x0a, 0xb4,
		     0x87, 0x5b, 0xf5, 0xe6};
	u8 data2[]= {0x7e, 0x03, 0x91, 0x35, 0x0d, 0xa8, 0x0e, 0x4b,
	             0x5d, 0xd5, 0x10, 0xd4, 0xaa, 0x77, 0x54, 0x3d,
		     0x90, 0x9c, 0xe9, 0xe9, 0x64, 0xfc, 0xe5, 0xd1,
		     0x66, 0x4a, 0xc8, 0x00, 0x1d, 0x9b, 0x0a, 0xb4,
		     0x87, 0x5b, 0xf5, 0xe6};
	u8 data3[]= {0x7e, 0x03, 0x91, 0x35, 0x0d, 0xa8, 0x0e, 0x4b,
	             0x5d, 0xd9, 0x10, 0xd1, 0xaa, 0x77, 0x54, 0x3d,
		     0x90, 0x9c, 0xe9, 0xe9, 0x64, 0xfc, 0xe5, 0xd1,
		     0x66, 0x4a, 0xc8, 0x00, 0x1d, 0x9b, 0x0a, 0xb4,
		     0x87, 0x5b, 0, 0};
	u8 data4[]= {0x7e, 0x03, 0x91, 0x35, 0x0d, 0xa8, 0x0e, 0x4b,
	             0x5d, 0xd5, 0x10, 0xd4, 0xaa, 0x77, 0x54, 0x3d,
		     0x90, 0x9c, 0xe9, 0xe9, 0x64, 0xfc, 0xe5, 0xd1,
		     0x66, 0x4a, 0xc8, 0x00, 0x1d, 0x9b, 0x0a, 0xb4,
		     0x87, 0x5b, 0, 0};
	u8 data5[]= {
		0xde, 0x45, 0xd5, 0xe5, 0x49, 0xce, 0xba, 0xe0, 0xf0, 0xec, 0x05, 0x97, 0x1d, 0xce, 0xe4, 0x79,
		0xce, 0xdf, 0xc4, 0xe4, 0x50, 0x2a, 0x99, 0x98, 0x99, 0xe3, 0xbd, 0x07, 0xbe, 0x51, 0x1d, 0xc2,
		0xcb, 0x10, 0x7e, 0x6d, 0x78, 0xc8, 0x83, 0x43, 0xfe, 0x72, 0x16, 0x6b, 0x1a, 0xeb, 0x75, 0x0c,
		0xb1, 0x81, 0xc8, 0x93, 0x8e, 0xe9, 0x22, 0xfc, 0xe7, 0x59, 0x7c, 0x83, 0x27, 0x05, 0x57, 0x00,
		0x9e, 0x3e, 0x81, 0xfe, 0xd7, 0xd4, 0x00, 0xf3, 0x5a, 0x43, 0xd2, 0xda, 0xc6, 0x0a, 0x90, 0xc5,
		0xe2, 0xbc, 0xdd, 0x5d, 0x82, 0xb1, 0x70, 0xa2, 0xe2, 0xdf, 0x55, 0x3c, 0xf6, 0x5a, 0x92, 0x72,
		0x10, 0x44, 0x5c, 0x00, 0x9f, 0x0f, 0x1e, 0x93, 0xc9, 0x1b, 0x55, 0x0f
	};
	u8 data6[]= {
		0xde, 0x45, 0xd5, 0xe5, 0x49, 0xce, 0xba, 0xe0, 0xf0, 0xec, 0x05, 0x97, 0x1d, 0xce, 0xe4, 0x79,
		0xce, 0xdf, 0xc4, 0xe4, 0x50, 0x2a, 0x99, 0x98, 0x99, 0xe3, 0xbd, 0x07, 0xbe, 0x51, 0x1d, 0xc2,
		0xcb, 0x10, 0x7e, 0x6d, 0x78, 0xc8, 0x83, 0x43, 0xfe, 0x72, 0x16, 0x6b, 0x1a, 0xeb, 0x75, 0x0c,
		0xb1, 0x81, 0xc8, 0x93, 0x8e, 0xe9, 0x22, 0xfc, 0xe7, 0x59, 0x7c, 0x83, 0x27, 0x05, 0x57, 0x00,
		0x9e, 0x3e, 0x81, 0xfe, 0xd7, 0xd4, 0x00, 0xf3, 0x69, 0x43, 0xd2, 0xda, 0xc6, 0x0a, 0x90, 0xc5,
		0xe2, 0xbc, 0xdd, 0x5d, 0x82, 0xb1, 0x70, 0xa2, 0xe2, 0xdf, 0x55, 0x3c, 0xf6, 0x5a, 0x92, 0x72,
		0x10, 0x44, 0x5c, 0x00, 0x9f, 0x0f, 0x1e, 0x93, 0xc9, 0x1b, 0x55, 0x0f
	};

	printf("%04x\n", crc16(0, data3, sizeof data3));
	printf("%04x\n", crc16(0, data4, sizeof data4));
	printf("%04x\n", crc16(0, data5, sizeof data5));
	printf("%04x\n", crc16(0, data5, sizeof data6));

	split_init();

	for (i=0; i<NUM_OF_TESTS; ++i) {
		// generate a random length of a packet[0..LINK_DATA_MAX]
		n = random_range(LINK_DATA_MAX);
		if (!n)
			continue;
#ifdef VERBOSE
		printf("no.%d, f=%d, tot=%d\n", i, fail, n);
#endif
		// generate the pkt of length n
		random_bytes(s, n);
#ifdef VERBOSE
		printf("-------------\n");

		printf("\nsend buf\n");
		//hex_dump(stdout, s, n, 0, true);
#endif
		n = upper_send(2, 1, s, n);
		// the return value 'n' is the actural submitted length
#ifdef VERBOSE
		printf("%d bytes accepted\n", n);
#endif

retry:
		do {
			int n_err;
			int j;
			int pos;
			int x;

#ifdef VERBOSE
			printf("\nlfetch & lput\n");
#endif
			len = sizeof low;
			ret = lower_fetch(low, &len);
#ifdef VERBOSE
			printf("ret=%d, len=%d, type=%d\n", ret, len, low[3]);
			//hex_dump(stdout, low, len, 0, true);
#endif
		//printf("%d %d\n", len, low[3]);
		//if (low[3] == 4 && len < 50)
		//	hex_dump(stdout, low, len, 0, true);
			if (!len)
				break;

#ifdef GEN_ERR
			// generate err
			x = len / 20; // err rate <= 5%
			if (x) {
				n_err = random_range(x);	// num of err
#ifdef VERBOSE
				printf("n_err=%d <------------\n", n_err);
#endif
				for (j=0; j < n_err; ++j) {
					pos = random_range(len);// random pos
#ifdef VERBOSE
					printf("pos=%02x, %02x->", pos, low[pos]);
#endif
					low[pos] = random_uint8();
#ifdef VERBOSE
					printf("%02x\n", low[pos]);
#endif
				}
			}
#endif

			lower_put(low, len);
		} while(1);

		// simulate timer working proc
		if (!get_urq_num() && !get_lsq_num())
			proc_timer();
		if (get_lsq_num() > 0) {
			// if timer gen some pkts
#ifdef VERBOSE
			printf("timeout...and try again\n");
#endif
			goto retry;
		}

#ifdef VERBOSE
		printf("\nrecv\n");
#endif
		len = sizeof r;
		ret = upper_recv(r, &len);
#ifdef VERBOSE
		printf("ret=%d, len=%d\n", ret, len);
		//hex_dump(stdout, r, len, 0, true);
#endif
		if (again && !len) {
			++ fail;
#ifdef VERBOSE
			printf("len=0, fail=%d\n", fail);
#endif
			continue;
		}

		if (memcmp(s, r, n)) {
			printf("orig(%d)---------------\n", n);
			hex_dump(stdout, s, n, 0, true);
			printf("err(%d)---------------\n", len);
			hex_dump(stdout, r, len, 0, true);
			printf("#####\n");
			++ fail;
#ifdef VERBOSE
			printf("mismatch, fail=%d\n", fail);
#endif
		}
		else {
			// "ack all" may lost
			if (again) {
				proc_timer();
				if (get_lsq_num() > 0) {
					again = false;
					goto retry;
				}
			}
			again = true;
		}
	}
	printf("\n\nfail=%d\n", fail);

	split_cleanup();

	return 0;
}
